---
id: programmercarl07
slug: /programmercarl07
title: 回溯算法
date: 2002-09-26
authors: 鲸落
tags: [代码随想录, 算法]
keywords: [代码随想录, 算法]
---





## 理论知识

### 什么是回溯法

回溯法也可以叫做回溯搜索法，它是一种搜索的方式。回溯是递归的副产品，只要有递归就会有回溯。



### 回溯法的效率

回溯法的性能如何呢，这里要和大家说清楚了，**虽然回溯法很难，很不好理解，但是回溯法并不是什么高效的算法**。

**因为回溯的本质是穷举，穷举所有可能，然后选出我们想要的答案**，如果想让回溯法高效一些，可以加一些剪枝的操作，但也改不了回溯法就是穷举的本质。

那么既然回溯法并不高效为什么还要用它呢？

因为没得选，一些问题能暴力搜出来就不错了，撑死了再剪枝一下，还没有更高效的解法。



### 回溯法解决的问题

回溯法，一般可以解决如下几种问题：

- 组合问题：N个数里面按一定规则找出k个数的集合
- 切割问题：一个字符串按一定规则有几种切割方式
- 子集问题：一个N个数的集合里有多少符合条件的子集
- 排列问题：N个数按一定规则全排列，有几种排列方式
- 棋盘问题：N皇后，解数独等等

**相信大家看着这些之后会发现，每个问题，都不简单！**

另外，会有一些同学可能分不清什么是组合，什么是排列？

**组合是不强调元素顺序的，排列是强调元素顺序**。

例如：{1, 2} 和 {2, 1} 在组合上，就是一个集合，因为不强调顺序，而要是排列的话，{1, 2} 和 {2, 1} 就是两个集合了。

记住组合无序，排列有序，就可以了。



### 如何理解回溯法

**回溯法解决的问题都可以抽象为树形结构**，是的，我指的是所**有回溯法的问题都可以抽象为树形结构**！

因为回溯法解决的都是在集合中递归查找子集，**集合的大小就构成了树的宽度（一般for循环来处理），递归的深度就构成了树的深度（一般递归来处理）**。

递归就要有终止条件，所以必然是一棵高度有限的树（N叉树）。



### 回溯法模板

这里给出Carl总结的回溯算法模板。回溯三部曲：

1. 回溯函数模板返回值以及参数

   - 因为回溯算法需要的参数可不像二叉树递归的时候那么容易一次性确定下来，所以一般是先写逻辑，然后需要什么参数，就填什么参数

2. 回溯函数终止条件

   - 什么时候达到了终止条件，树中就可以看出，一般来说搜到叶子节点了，也就找到了满足条件的一条答案，把这个答案存放起来，并结束本层递归。

3. 回溯搜索的遍历过程

   - 回溯法一般是在集合中递归搜索，集合的大小构成了树的宽度，递归的深度构成的树的深度。
   - ![回溯算法理论基础](回溯算法.assets/20210130173631174.png)

   - for循环就是遍历集合区间，可以理解一个节点有多少个孩子，这个for循环就执行多少次。
   - backtracking这里自己调用自己，实现递归。
   - 大家可以从图中看出**for循环可以理解是横向遍历，backtracking（递归）就是纵向遍历**，这样就把这棵树全遍历完了，一般来说，搜索叶子节点就是找的其中一个结果了。



```js
void backtracking(参数){
    if(终止条件){
        // 一般情况下，终止条件就到了我们收集结果的时候了，大部分情况下都是会在叶子节点的时候去收集结果，有的会在每个节点就去收集结果
        收集结果
        return;
    }
    
    // 进入单层搜索的逻辑，一般情况下是一个for循环，用来处理这个集合中的每一个元素
    for(集合的元素集){
        处理节点（处理满足条件的节点）
        递归函数（进入递归的过程）
        回溯操作（撤销处理节点的情况）
    }
}
```



## 组合

https://programmercarl.com/0077.%E7%BB%84%E5%90%88.html

https://leetcode.cn/problems/combinations/description/



### 思路

从下图中红线部分可以看出，在集合[1,2,3,4]取1之后，下一层递归，就要在[2,3,4]中取数了，那么下一层递归如何知道从[2,3,4]中取数呢，靠的就是startIndex。所以需要startIndex来记录下一层递归，搜索的起始位置。

![77.组合2](回溯算法.assets/20201123195328976.png)





### 未剪枝

```js
var combine = function(n, k) {
    
    const arr = []
    const result = []

    function backtracking(startIndex){
        if(arr.length === k){
            result.push([...arr])
            return
        }

        for(let i = startIndex;i<= n;i++){
            arr.push(i)
            backtracking(i+1)
            arr.pop()
        }
    }

    backtracking(1)

    return result

};
```

:::info 为什么循环调用的是`backtracking(i+1)` 而不是 `backtracking(startIndex+1)`

`backtracking(i + 1)`的含义是：

- 我现在选了数字 `i`
- 下一层应该从 `i + 1` 开始（即不能再选当前的 `i` 了，避免重复）

这相当于说：

> 每次递归往下传的是“我刚刚选了谁，接下来只能选比它更大的数字”。

`backtracking(startIndex + 1)`的意思是：

- 不管我当前选了谁，我下一轮都从 **startIndex + 1** 开始选

问题就来了：

- **`i` 和 `startIndex` 可能是不一样的！**
- 如果你在循环里枚举了 `i`，就必须传 `i + 1`，不然会跳过一部分情况，或重复访问某些数字。

**记住**：

在回溯算法中：

- **如果你在 for 循环里枚举的是 `i`**
- 那么递归就要 `backtracking(i + 1)`，才能正确推进枚举范围

:::



注意点：

- 不能直接`result.push(arr)`，要使用浅拷贝保存当前组件`result.push([...arr])`
- 递归调用的是`backtracking(i+1)`，如果使用`i`会导致重复使用相同的数字，无法确保组合中数字是递增且不重复的





### 剪枝优化

当 `arr.length + (n - i + 1) < k` 时，就不可能凑够 `k` 个数了，可以跳过。

所以我们可以限制i的最大范围：`i <= n - (k - arr.length) + 1`

```js
var combine = function(n, k) {
    
    const arr = []
    const result = []

    function backtracking(startIndex){
        if(arr.length === k){
            result.push([...arr])
            return
        }

        for(let i = startIndex;i <= n - (k - arr.length) + 1;i++){
            arr.push(i)
            backtracking(i+1)
            arr.pop()
        }
    }

    backtracking(1)

    return result

};
```

**解释剪枝条件**：

如果当前已经选了 `arr.length` 个数，还差 `k - arr.length` 个，那么：

- 最后一个可能的起始数字是：`n - (k - arr.length) + 1`
- 再往后的 `i` 都无法凑够剩下的组合，直接跳过。



## 组合总和III

https://programmercarl.com/0216.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CIII.html

https://leetcode.cn/problems/combination-sum-iii/description/



### 思路

与组件是一个思路



### 未剪枝

```js
var combinationSum3 = function(k, n) {
    const result = []
    let arr = []

    function backtracking(startIndex){
        if( arr.length === k &&  [...arr].reduce((sum, num) => sum + num, 0) === n ){
            result.push([...arr])
            return
        }

        for(let i = startIndex;i<= 9;i++){
            arr.push(i)
            backtracking(i+1)
            arr.pop()
        }
    }

    backtracking(1)

    return result
};
```



### 剪枝

```js
var combinationSum3 = function(k, n) {
    const result = []
    let arr = []
    let sum = 0

    function backtracking(startIndex){
        if(sum > n) return

        if( arr.length === k &&  sum === n ){
            result.push([...arr])
            return
        }

        for(let i = startIndex;i <= 9 - (k - arr.length) + 1;i++){
            arr.push(i)
            sum += i
            backtracking(i+1)
            arr.pop()
            sum -= i
        }
    }

    backtracking(1)

    return result
};
```



## 电话号码的组合

https://programmercarl.com/0017.%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88.html

https://leetcode.cn/problems/letter-combinations-of-a-phone-number/description/



### 思路

### 代码

```js
/**
 * @param {string} digits
 * @return {string[]}
 */
var letterCombinations = function(digits) {
    if (digits.length === 0) return []

    const arr1 = [
        [],
        [],
        ["a", "b", "c"],
        ["d", "e", "f"],
        ["g", "h", "i"],
        ["j", "k", "l"],
        ["m", "n", "o"],
        ["p", "q", "r", "s"],
        ["t", "u", "v"],
        ["w", "x", "y", "z"],
    ]

    const arr2 = digits.split("").map(item => Number(item))

    const result = []
    let arr = []

    function backtracking(index){
        // index就是用来遍历digits
        if( index === arr2.length ){
            result.push([...arr].join(""))

            return
        }

        const arr3 = arr1[arr2[index]]

        for(let i = 0;i < arr3.length; i++){
            arr.push(arr3[i])
            backtracking(index+1)
            arr.pop()
        }
    }

    backtracking(0)

    return result
};
```



## 组合总和

https://programmercarl.com/0039.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C.html

https://leetcode.cn/problems/combination-sum/description/



### 思路

### 代码

```js
var combinationSum = function(candidates, target) {
    const result = []
    let sum = 0
    let arr = []

    function backtracking(index){
        if (sum > target || arr.length > 150) return

        if(arr.length <= 150 && sum === target){
            result.push([...arr])
            return
        }

        for(let i = index;i < candidates.length; i++){
            arr.push(candidates[i])
            sum += candidates[i]
            backtracking(i)
            const a = arr.pop()
            sum -= a
        }
    }

    backtracking(0)

    return result
};
```



注意：涉及到和，就有和大于对比值的情况，需要去除掉



## 组合总和II

https://programmercarl.com/0040.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CII.html

https://leetcode.cn/problems/combination-sum-ii/description/



### 思路

先排序



### 代码

```js
var combinationSum2 = function(candidates, target) {
    candidates.sort((a, b) => a - b)

    const result = []
    let sum = 0
    let arr = []

    function backtracking(index){
        if (sum > target) return

        if(sum === target){
            result.push([...arr])
            return
        }

        for(let i = index;i < candidates.length; i++){
            if(i > index && candidates[i] === candidates[i-1] ) continue 
            arr.push(candidates[i])
            sum += candidates[i]
            backtracking(i+1)
            const a = arr.pop()
            sum -= a
        }
    }

    backtracking(0)

    return result
};
```

:::info 为什么是`candidates[i] === candidates[i-1]`进行`continue`

关键区别不在“值”，而在**树的层级（递归路径）**

我们**并不是跳过所有的重复值**，而是只跳过“**在同一递归层级**中的重复值”。

我们允许：

- 不同递归层中的重复值 ✅
- 同一层中的重复值 ❌（因为会导致重复组合）

举个例子：`candidates = [1, 1, 2]，target = 3`

我们展开递归树（简化为只显示值）：

```less
Level 0: []
  ├── Level 1: [1]    // i = 0
  │     ├── [1,1]     // i = 1
  │     │     └── [1,1,2] -> 超出
  │     └── [1,2] ✅  // i = 2
  └── Level 1: [1] ❌ // i = 1 ←⚠️ 重复了第一条路径的组合
        └── [1,2] ← 重复路径
```

所以判断：`if (i > start && candidates[i] === candidates[i - 1])`

它的意思是：

- `i > start`：说明我们正在当前递归的“同一层级”中横向遍历
- `candidates[i] === candidates[i - 1]`：两个值相同
- → 那就跳过当前这个 `candidates[i]`，因为你**已经在这一层用过一次相同的值了**，再用就是重复组合。

:::



## 分割回文串

https://programmercarl.com/0131.%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2.html

https://leetcode.cn/problems/palindrome-partitioning/description/



### 思路

### 代码

```js
var partition = function(s) {
    let result = []
    let arr = []

    function backtracking(startIndex){
        if(startIndex === s.length){
            result.push([...arr])
            return
        }

        for(let i = startIndex;i < s.length;i++){
            if(!isH(s, startIndex, i)) continue
            arr.push(s.slice(startIndex, i + 1))
            backtracking(i+1)
            arr.pop()
        }
    }

    backtracking(0)

    return result
};

function isH(str, start, end){
    for(let i = start, j = end; i < j;i++,j--){
        if(str[i] !== str[j]){
            return false
        }
    }

    return true
}
```

:::info 为什么循环结束条件是`startIndex === s.length`

当 `index === s.length`，说明**已经处理完了整个字符串**，到达了叶子节点，当前路径 `arr` 中保存的是一种合法的回文划分结果，可以加入结果集了。

:::































































