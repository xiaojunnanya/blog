---
id: programmercarl01
slug: /programmercarl01
title: 算法
date: 2002-09-26
authors: 鲸落
tags: [代码随想录, 算法]
keywords: [代码随想录, 算法]
---





## 数组

### 理论知识

- 数组下标都是从0开始的。
- 数组内存空间的地址是连续的

正是因为数组在内存空间的地址是连续的，所以我们在删除或者增添元素的时候，就难免要移动其他元素的地址。



### 二分查找

https://programmercarl.com/0704.%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.html

https://leetcode.cn/problems/binary-search/

#### 思路

明确好区间的定义，是左闭右闭即[left, right]，还是左闭右开即[left, right)



#### 方法一：左闭右闭即[left, right]

**定义target在[left, right]区间，所以有如下两点**：

- while (left <= right) 要使用 <= ，因为left == right是有意义的，所以使用 <=
- if (nums[middle] > target) right 要赋值为 middle - 1，因为当前这个nums[middle]一定不是target，那么接下来要查找的左区间结束下标位置就是 middle - 1

```typescript
function search(nums: number[], target: number): number {
    
    let left = 0
    let right = nums.length - 1

    while(left <= right){
        let i  = Math.floor((left + right) / 2)
        if(nums[i] === target){
            return i
        }else{
            if( nums[i] > target ){
                right = i - 1
            }else{
                left = i + 1
            }
        }
    }


    return -1
};
```



> 1、为什么要用 `Math.floor` 而不是 `Math.ceil`
>
> 如果使用 `Math.ceil`，在某些情况下，`left` 和 `right` 很靠近，`mid` 会更偏向右边，可能导致死循环。
>
> 举例：
>
> - 如果 `left = 1`, `right = 2`
>   - `floor((1 + 2)/2) = 1`，下一步可能设置 `left = 2` 或 `right = 0`，总能跳出循环；
>   - 但 `ceil((1 + 2)/2) = 2`，如果逻辑不当，就会卡在 `left = 1, right = 2` 的循环中。
> - 使用 `Math.floor` 是为了避免死循环，让中间值偏向左边更稳定；
> - 使用 `Math.ceil` 理论上也可，但需要更严格地处理边界，容易出错；



#### 方法二：左闭右开即[left, right)

如果说定义 target 是在一个在左闭右开的区间里，也就是[left, right) ，那么二分法的边界处理方式则截然不同。

有如下两点：

- while (left < right)，这里使用 < ,因为left == right在区间[left, right)是没有意义的
- if (nums[middle] > target) right 更新为 middle，因为当前nums[middle]不等于target，去左区间继续寻找，而寻找区间是左闭右开区间，所以right更新为middle，即：下一个查询区间不会去比较nums[middle]

```typescript
function search(nums: number[], target: number): number {
    
    let left = 0
    let right = nums.length

    while(left < right){
        let i  = Math.floor((left + right) / 2)
        if(nums[i] === target){
            return i
        }else{
            if( nums[i] > target ){
                right = i
            }else{
                left = i + 1
            }
        }
    }


    return -1
};
```



> 这个相较于左闭右闭不好理解
>
> - 首先是`let right = nums.length`，因为定义target在左闭右开的区间里，即：[left, right)
> - while (left < right) ， 因为left == right的时候，在[left, right)是无效的空间，所以使用 <
> - right = middle，因为target 在左区间，在[left, middle)中



### 移除元素

https://programmercarl.com/0027.%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0.html

https://leetcode.cn/problems/remove-element/description/

#### 思路

题目要求：需要**原地**移除

因为元素在内存地址中是连续的，不能单独删除数组中的某个元素，所以只能覆盖



#### 暴力解法

暴力的解法就是两层for循环，一个for循环遍历数组元素 ，第二个for循环更新数组。

```typescript
function removeElement(nums: number[], val: number): number {
    let n = nums.length

    for(let i = 0; i <n; i++){
        if( nums[i] === val ){
            for(let j = i+1; j<n; j++){
                nums[j - 1] = nums[j]
            }
            i--
            n--
        }
    }

    return n
};
```

> 1、为什么要i--
>
> 因为当前 `i` 位置又是新元素了，必须重新检查这个位置！所以 `i--`。



#### 双指针法

双指针法（快慢指针法）： **通过一个快指针和慢指针在一个for循环下完成两个for循环的工作。**

定义快慢指针

- 快指针：寻找新数组的元素 ，新数组就是不含有目标元素的数组
- 慢指针：指向更新 新数组下标的位置

```
function removeElement(nums: number[], val: number): number {
    let slowIndex = 0

    for(let fastIndex = 0; fastIndex < nums.length; fastIndex++){
        if(nums[fastIndex] !== val){
            nums[slowIndex] = nums[fastIndex] // 保留有效值
            slowIndex++
        }
    }

    return slowIndex
};
```



#### 其他解决方法

这种方式是我自己想到的，定义两个指针，一个从开头，一个从结尾开始交换

```typescript

function removeElement(nums: number[], val: number): number {
    let i = 0
    let j = nums.length - 1

    for(;i<=j;i++){
        if(nums[i] === val){
            nums[i] = nums[j]
            j--
            i-- // 这里的i为什么要--需要理解
        }
    }

    return i
};
```



### 有序数的平方

https://programmercarl.com/0977.%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9.html

https://leetcode.cn/problems/squares-of-a-sorted-array/description/

#### 思路



#### 暴力解法

先平方在排序

```typescript
function sortedSquares(nums: number[]): number[] {
    return nums.map(item => item * item).sort((a, b) => a - b)
};
```



#### 双指针

数组其实是有序的， 只不过负数平方之后可能成为最大数了。

那么数组平方的最大值就在数组的两端，不是最左边就是最右边，不可能是中间。

此时可以考虑双指针法了，i指向起始位置，j指向终止位置。

```typescript
function sortedSquares(nums: number[]): number[] {
    let arr = []

    let i = 0
    let j = nums.length - 1

    while(i <= j){
        let a = nums[i] * nums[i]
        let b = nums[j] * nums[j]
        if( a >= b){
            arr.unshift(a)
            i++
        }else{
            arr.unshift(b)
            j--
        }
    }

    return arr
};
```

























































































































































































































































































