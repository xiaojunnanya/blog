---
id: leetcode
slug: /buildAndCount/leetcode
title: 力扣刷题(2023暑期版)
date: 2002-09-26
authors: 鲸落
tags: [数据结构, 算法]
keywords: [数据结构, 算法]
---

[力扣](https://leetcode.cn/)

[代码随想录 (programmercarl.com)](https://www.programmercarl.com/)

每一种题还给了相关题目推荐，在刷完一类题型的时候返回将每个题的相关类似题刷一下巩固一下

## 待

- 解析url
- 判断字符串对称的



## 数组

### 二分查找

[704. 二分查找 - 力扣（LeetCode）](https://leetcode.cn/problems/binary-search/)

```js
var search = function(nums, target) {
    const n = nums.length
    
    let left = 0
    let right = n - 1   
    
    while( left <= right ){
        let mid = Math.floor((left + right)/2)
        if( nums[mid] == target ){
            return mid
        }else{

            if( nums[mid] > target ){
                right = mid - 1
            }else{
                left = mid + 1
            }

        }

    }

    return -1

};
```



### 移除元素

[力扣 (leetcode.cn)](https://leetcode.cn/problems/remove-element/)

```js
var removeElement = function(nums, val) {
    const n = nums.length
	// 定义快慢指针
    let slow = 0
    for(let i = 0;i<nums.length;i++){
        // 当他们不相等的时候, 往后跑赋值
        if(nums[i] !== val){
            nums[slow++] = nums[i]
        }
    }

    return slow
};
```



### 有序数组的平方

[Loading Question... - 力扣（LeetCode）](https://leetcode.cn/problems/squares-of-a-sorted-array/)

#### 使用已有方法

```js
var sortedSquares = function(nums) {
    return nums.map(item => item*item).sort((a, b) => a-b)
};
```



#### 双指针

```js
var sortedSquares = function(nums) {
    let i = 0
    let j = nums.length - 1
    let arr = []
    while(i <= j){
        let a = nums[i] * nums[i]
        let b = nums[j] * nums[j]

        if( a < b ){
            arr.unshift(b)
            j--
        }else{
            arr.unshift(a)
            i++
        }

    }

    return arr

};
```



### 长度最小的子数组

[209. 长度最小的子数组 - 力扣（LeetCode）](https://leetcode.cn/problems/minimum-size-subarray-sum/)

#### 滑动窗口

```js
var minSubArrayLen = function(target, nums) {
   let n = nums.length

    let j = 0

    let num = 0
    let result = Number.MAX_VALUE
    let isChange = false
    for( let i = 0;i<n;i ++ ){
        num += nums[i]
        
        while( num >= target ){
            // 纪录最小值
            result = Math.min(result, i - j + 1)
            // j向前走，num要把那个之前的j值减掉
            num -= nums[j]
            j++
            isChange = true
        }

    }
    
    return isChange ? result : 0

};
```



### 螺旋矩阵 II

[59. 螺旋矩阵 II - 力扣（LeetCode）](https://leetcode.cn/problems/spiral-matrix-ii/)

```js
// 第一圈循环

var generateMatrix = function(n) {
    // 填充二维数组全为0
    let arr = new Array(n).fill(0).map(() => new Array(n).fill(0))
    // 定义起始位置这定义了其实位置之后，我们要明确我们的循环规则：左闭右开
    let x = y =0
    // 定义我们循环的次数(根据n有两种情况)
    let loop = Math.floor(n/2)
    // 定义填充的值
    let count = 1

    
        let i = j = 0;
        // 上边的循环：为什么是n-1，因为左闭右开
        for(j = 0;j<n-1;j++){
			arr[i][j] = count++
        }
        
        // 右边的循环
        for(i = 0;i<n-1;i++){
            arr[i][j] = count++
        }
        
        // 下边的循环,j已经变成了n-1了不需要初始化值，当然你初始化也是没有问题的
        for(j = n-1; j >=0; j--){
            arr[i][j] = count++
        }
        
        //左边的循环,i已经变成了n-1了不需要初始化值，当然你初始化也是没有问题的
        for(i = n -1;i >=0;i--){
            arr[i][j] = count++
        }
     

};
```

```js
// 下一圈循环 --- 一圈一圈的循环

var generateMatrix = function(n) {
    // 我们还需要定义一些参数
    // 控制每条边的终止位置：
    // 其实对于控制终止位置我们定义一个参数就可以了，方便理解可以定义两个
    let offsetX = 1
    let offsetY = 1
    
    let arr = new Array(n).fill(0).map(() => new Array(n).fill(0))
    let x = y =0
    let loop = Math.floor(n/2)
    let count = 1

    while(loop--){
        let i = x, j = y;

        // for(j = 0;j<n-offsetX;j++)
        for(;j<n-offsetX;j++){
			arr[i][j] = count++
        }
        
        // for(i = 0;i<n-1;i++)
        for(;i<n-offsetY;i++){
            arr[i][j] = count++
        }
        
        for(; j >x; j--){
            arr[i][j] = count++
        }
        
        for(;i >y;i--){
            arr[i][j] = count++
        }
        
        x++
        y++
        offsetX++
        offsetY++
    }
    
    // n为奇数的情况，最中间的部分我们要填充上最后的count
    if( n %2 == 1){
        arr[Math.floor(n/2)][Math.floor(n/2)] = count
    }
     
	return arr
};
```



## 链表

### 移除链表元素

[203. 移除链表元素 - 力扣（LeetCode）](https://leetcode.cn/problems/remove-linked-list-elements/)

#### 原链表删除元素的方法

```js
var removeElements = function(head, val) {
    if(!head) return head

    //头结点值为val的情况
    while( head && head.val == val ){
        head = head.next
    }


    let cur = head
    while(cur){
        if( cur.next && cur.next.val == val ){
            cur.next = cur.next.next
        }else{
            cur = cur.next
        }     
    }

    return head

};
```

#### 使用虚拟头结点的方法

```js
var removeElements = function(head, val) {
    var newNode = new ListNode(-1, head); // 设置一个虚拟头节点
    var prev = newNode; // prev记录当前节点的前一个节点
    while(prev.next) { // 从head开始遍历链表
        if(prev.next.val === val) { // 如果当前节点的值等于val
            prev.next = prev.next.next // 跳过当前的节点
        } else {
            prev = prev.next // 如果不等于，继续遍历链表
        }
    }
    return newNode.next; // 返回头节点
};
```

#### 双指针法

```js
var removeElements = function(head, val) {
    if( !head ) return head
    
    while( head && head.val == val ){
        head = head.next
    }

    let current = head
    let pre = null
    while(current){
        if( current.val == val ){
            pre.next = current.next
        }else{
            pre = current
        }
        current = current.next
    }

    return head
};
```



### 设计链表

[707. 设计链表 - 力扣（LeetCode）](https://leetcode.cn/problems/design-linked-list/)



### 反转链表

[206. 反转链表 - 力扣（LeetCode）](https://leetcode.cn/problems/reverse-linked-list/)

#### 递归

```js
var reverseList = function(head) {
   // 递归结束条件
   if(head === null || head.next === null) return head

    // 在这个位置执行的代码是在递归前执行的代码

    const newHead = reverseList(head.next)  //  每一次递归结束返回的newHead就是上面的那个head

    // 在这个位置执行的代码是在递归后执行的代码

    // 在这里我们要理解，来到这个head是谁
    // 第一次来到这个的时候，head是倒数第二个节点，因为倒数第一个直接返回head了
    // 这个时候我们需要将倒数第一个指向倒数第二个,并将倒数第二个指针设为空
    head.next.next = head
    head.next = null

    return newHead
};
```

#### 栈

```js
var reverseList = function(head) {
    // 当我们的链表没有节点或只有一个节点的时候，可以直接返回
    if(head === null || head.next === null) return head
    // 用数组来模拟战
    let arr = []
    let current = head
    while(current){
        arr.push(current)
        current = current.next
    }

    // 创建一个新的head
    const newHead = arr.pop()
    let newHeadCurrent = newHead
    while(arr.length){
        let node = arr.pop()
        // 上一个出来的指向刚出来的
        newHeadCurrent.next = node
        //往下走
        newHeadCurrent = newHeadCurrent.next
    }
    
    // 注意一定要将最后一个newHeadCurrent的next设置为null
    newHeadCurrent.next = null

    return newHead

};
```



#### 双指针

```js
var reverseList = function(head) {
    let cur = head
    let pre = null

    while(cur){
        let temp = cur.next
        cur.next = pre
        pre = cur
        cur = temp
    }
    return pre
};
```



### 删除链表中的节点

[237. 删除链表中的节点 - 力扣（LeetCode）](https://leetcode.cn/problems/delete-node-in-a-linked-list/)

```js
// 其思路就是，我们把这个1的这个值给5，然后删除原来1位置的那个节点
var deleteNode = function(node) { 
    node.val = node.next.val
    node.next = node.next.next
};
```



### 两两交换链表中的节点

[24. 两两交换链表中的节点 - 力扣（LeetCode）](https://leetcode.cn/problems/swap-nodes-in-pairs/)

```js
var swapPairs = function(head) {
    let newNode = new ListNode(0, head)
    let cur = newNode
    // cur.next为空就是偶数的情况，cur.next.next就是奇数的情况
    while(cur.next !== null && cur.next.next !== null){
        // newNode -> 1 -> 2 -> 3 -> 4 -> 5

        // 纪录 1的位置
        let temp1 = cur.next
        // 纪录3的位置
        let temp2 = cur.next.next.next
        // newNode 指向 2
        cur.next = cur.next.next
        // 此时2 就是cur.next, 2指向1
        cur.next.next = temp1
        // 1指向3
        temp1.next = temp2

        // 接下来交换3/4，那么我们的cur就应该移动到1的位置：newNode -> 2 -> 1 -> 3 ...
        // cur.next在2的位置，cur.next.next跑到1
        cur = cur.next.next

    }
    return newNode.next
};
```





### 删除链表的倒数第 N 个结点

[19. 删除链表的倒数第 N 个结点 - 力扣（LeetCode）](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/)

```js
var removeNthFromEnd = function(head, n) {
    // 使用虚拟头肩点的方式
    let newNode = new ListNode(0, head)

    let cur = newNode
    let pre = newNode

    while(n--){
        cur = cur.next
    }

    while(cur.next){
        cur = cur.next
        pre = pre.next
    }

    pre.next = pre.next.next

    return newNode.next

};
```



### 链表相交

[面试题 02.07. 链表相交 - 力扣（LeetCode）](https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/)

思路：[【图解：双指针】JavaScript - 链表相交 - 力扣（LeetCode）](https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/solution/tu-jie-shuang-zhi-zhen-javascript-by-lzx-zd6z/)

```js
var getIntersectionNode = function(headA, headB) {
    let a = headA
    let b = headB

    while(a !== b){
        a = a === null ? headB: a.next
        b = b === null ? headA: b.next
    }

    return a
};
```



### 环形链表II

[142. 环形链表 II - 力扣（LeetCode）](https://leetcode.cn/problems/linked-list-cycle-ii/)

```js
var detectCycle = function(head) {
    if(!head || !head.next) return null;
    // 定义快慢指针
    let slow =head.next, fast = head.next.next;
    while(fast && fast.next) {
        slow = slow.next;
        fast = fast.next.next;
        // 相等即是相遇
        if(fast == slow) {
            // 从头结点开始跑，还有一个从相遇点开始，当他们再次相遇的时候，即是环开始点
            slow = head;
            while (fast !== slow) {
                slow = slow.next;
                fast = fast.next;
            }
            return slow;
        }
    }
    return null;
};
```



### 总结

- `while(head)`： 这个循环条件表示只要 `head` 节点不为 `null`（或者指向有效节点），就会继续执行循环体。这意味着循环会遍历链表的所有节点，包括最后一个节点。因此，循环内部的操作将会在每个节点上执行。

- `while(head.next)`： 这个循环条件表示只要 `head` 节点的下一个节点 `head.next` 不为 `null`（或者指向有效节点），就会继续执行循环体。这意味着循环会遍历链表的除了最后一个节点之外的其他所有节点，不包括最后一个节点。因此，循环内部的操作将会在除了最后一个节点之外的每个节点上执行。



## 字符串

### 反转字符串

[344. 反转字符串 - 力扣（LeetCode）](https://leetcode.cn/problems/reverse-string/)

**双指针法**

```js
var reverseString = function(s) {
    let i = 0
    let j = s.length - 1
    while(i < j){
        [ s[i], s[j] ] = [ s[j], s[i] ]
        i++
        j--
    }
};
```



### 反转字符串II

[541. 反转字符串 II - 力扣（LeetCode）](https://leetcode.cn/problems/reverse-string-ii/)

```js
var reverseStr = function(s, k) {
    let arr = s.split('');
    // 每隔 2k 个字符的前 k 个字符进行反转
    for(let i = 0; i < arr.length; i += 2 * k) {
        let l = i;
        // i + k <= arr.length说明剩余字符小于 2k 但大于或等于 k 个，反转前 k 个字符
        // i + k > arr.length剩余字符少于 k 个，则将剩余字符全部反转
        let r = i + k <= arr.length ? i + k - 1 : arr.length - 1;
        while(l < r) {
            [arr[l], arr[r]] = [arr[r], arr[l]];
            l++;
            r--;
        }
    }
    return arr.join('');
};
```



### 替换空格

[剑指 Offer 05. 替换空格 - 力扣（LeetCode）](https://leetcode.cn/problems/ti-huan-kong-ge-lcof/)

```js
var replaceSpace = function(s) {
    let a = s.split('')

    for(let i = 0;i<a.length;i++){
        if(a[i] == ' ') a[i] = '%20'
    }

    return a.join('')
};
```

```js
var replaceSpace = function(s) {
    return s.split(' ').join('%20')
};
```



### 反转字符串中的单词

[151. 反转字符串中的单词 - 力扣（LeetCode）](https://leetcode.cn/problems/reverse-words-in-a-string/)

**容易想到的思路**

```js
var reverseWords = function(s) {
    let a = s.split(' ')
    let arr = []
    for(let i = 0; i< a.length;i++){
        if( a[i] != '' ){
            arr.unshift(a[i])
        }
    }
	
    return arr.join(" ")
};
```



**进阶**：使用 `O(1)` 额外空间复杂度的 **原地** 解法。



### 左旋转字符串

[剑指 Offer 58 - II. 左旋转字符串 - 力扣（LeetCode）](https://leetcode.cn/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/)

**数组头出尾进**

```js
var reverseLeftWords = function(s, n) {
    if( n >= s.length ) return s

    let a = s.split('')
    for(let i = 0; i< n ;i++){
        a.push(a.shift())
    }
    return a.join("")
};
```



**截取拼接**

```js
var reverseLeftWords = function(s, n) {
    if( n >= s.length ) return s
    return s.slice(n) + s.slice(0, n)
};
```



**将字符串双倍然后截取：**[【双倍字符串+截取】JavaScript - 左旋转字符串 - 力扣（LeetCode）](https://leetcode.cn/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/solution/shuang-bei-zi-fu-chuan-jie-qu-javascript-bzzv/)

```js
const reverseLeftWords = (s, k) => {
    const n = s.length;
    let a = s + s
    return a.slice(k, n+k)
};

var reverseLeftWords = function(s, n) {
    let a = s + s
    return a.substr(n, s.length)
};
```



### 找出字符串中第一个匹配项的下标

这题是经典的KMP算法

[28. 找出字符串中第一个匹配项的下标 - 力扣（LeetCode）](https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/)

```js
var strStr = function(haystack, needle) {
    return haystack.indexOf(needle)
};
```

```js
var strStr = function(haystack, needle) {
    let i = 0

    let n = needle.length
    while(  i < haystack.length - n + 1  ){
        if( haystack[i] == needle[0] && haystack.substr(i, n) == needle ){
            return i
        }else{
            i++
        }
    }

    return -1
}
```



### 重复的子字符串

这也是KMP的经典题目

[459. 重复的子字符串 - 力扣（LeetCode）](https://leetcode.cn/problems/repeated-substring-pattern/)

**移动匹配**

```js
var repeatedSubstringPattern = function(s) {
    let a = s + s
    let b = a.slice(1,a.length-1)
    return b.includes(s)
};
```



### 最长回文子串

[5. 最长回文子串 - 力扣（LeetCode）](https://leetcode.cn/problems/longest-palindromic-substring/)

#### 解题思路

- 两种情况

  - 一种是回文子串长度为奇数（如aba，中心是b）

  - 另一种回文子串长度为偶数（如abba，中心是b，b）

- 核心就是循环遍历字符串 对取到的每个值 都假设他可能成为最后的中心进行判断



#### 循环截取字符串法

```js
var longestPalindrome = function(s) {
    	const a = s.length
        if (a<2) return s
        let res = ''
        for (let i = 0; i < s.length; i++) {
            // 回文子串长度是奇数
            helper(i, i)
            // 回文子串长度是偶数
            helper(i, i + 1) 
        }

        function helper(m, n) {
            while (m >= 0 && n < a && s[m] == s[n]) {
                m--
                n++
            }
            // 注意此处m,n的值循环完后  是恰好不满足循环条件的时刻
            // 此时m到n的距离为n-m+1，但是mn两个边界不能取 所以应该取m+1到n-1的区间  长度是n-m-1
            if (n - m - 1 > res.length) {
                // slice也要取[m+1,n-1]这个区间 
                res = s.slice(m + 1, n)
            }
        }
        return res
};
```



#### 双指针法

```js
var longestPalindrome = function(s) {
    	const a = s.length
        if (a<2) return s
        let l = 0
        let r = 0
        for (let i = 0; i < s.length; i++) {
            // 回文子串长度是奇数
            helper(i, i)
            // 回文子串长度是偶数
            helper(i, i + 1) 
        }

        function helper(m, n) {
            while (m >= 0 && n < a && s[m] == s[n]) {
                m--
                n++
            }
            // 注意此处m,n的值循环完后  是恰好不满足循环条件的时刻
            if (n - m - 1 > r - l - 1) {
               l = m
               r = n
            }
        }

        return s.slice(l+1, r)
};
```



### 最长公共前缀

[14. 最长公共前缀 - 力扣（LeetCode）](https://leetcode.cn/problems/longest-common-prefix/)

逐位比较，比较全部通过时`res`增加当前字符，不通过时直接返回`res`

```js
var longestCommonPrefix = function(strs) {
    let res = ''
    let n = strs.length
    
    for(let i = 0;i<strs[0].length;i++){
        for(let j = 1;j<strs.length;j++){
            if(strs[j][i] !== strs[0][i]) return res
        }
        res += strs[0][i]
    }
    return res
};
```



### 无重复字符的最长子串

[3. 无重复字符的最长子串 - 力扣（LeetCode）](https://leetcode.cn/problems/longest-substring-without-repeating-characters/)

- 解题思路： 使用一个数组来维护滑动窗口
- 遍历字符串，判断字符是否在滑动窗口数组里
  - 不在则 push 进数组
  - 在则删除滑动窗口数组里相同字符及相同字符前的字符，然后将当前字符 push 进数组
  - 然后将 max 更新为当前最长子串的长度
- 遍历完，返回 max 即可

```js
var lengthOfLongestSubstring = function(s) {
    let max = 0
    let arr = []
    for(let i = 0;i<s.length;i++){
        let index = arr.indexOf(s[i])
        // 当部位-1的时候，我们先执行删除操作，将当前的也删掉，然后下面继续执行push，将相同的元素加上
        if(index !== -1){
            arr.splice(0, index+1)
        }
        arr.push(s[i])
        max = Math.max(max, arr.length)
    }
    return max
};
```









## 双指针

### 三数之和

[15. 三数之和 - 力扣（LeetCode）](https://leetcode.cn/problems/3sum/)

```js
/**
 * @param {number[]} nums
 * @return {number[][]}
 */
var threeSum = function(nums) {
    nums.sort((a,b) => a-b)
    let arr = []
    const n = nums.length
    for(let i = 0;i<n-2;i++){
        // 当第一个数大于0的时候可以直接结束了
        if(nums[i] > 0) break
        // 当前数等于前一个数,结束当前的i
        if( i>0 && nums[i] === nums[i-1] ) continue
        let left = i+1
        let right = n-1
        while(left < right){
            let sum = nums[i] + nums[left] + nums[right]
            if(sum > 0 ){
                right--
            }
            if(sum < 0){
                left++
            }
            
            if(sum == 0){
                arr.push([nums[i], nums[left], nums[right] ])
                 // 去重：去除这样的情况：[-2,0,0,2,2]
                while(left < right && nums[left] == nums[left + 1]){
                    left++
                }
                while(left < right && nums[right] == nums[right - 1]) {
                    right--
                }
                left++
                right--
            }

        }
        

    }

    return arr
};
```



### 四数之和

[18. 四数之和 - 力扣（LeetCode）](https://leetcode.cn/problems/4sum/)

```js
 var fourSum = function(nums, target) {
    nums.sort((a,b) => a-b)
    const n = nums.length
    let arr = []
    for(let i = 0;i< n-3;i++){
        // 这里不能直接添加大于target，因为target可能为负数
        if( target >0 && nums[i] > target) break
        if(i>0 && nums[i] == nums[i-1]) continue

        for(let j = i+1;j< n-2;j++){
            // 这里我们也可以添加一个剪枝判断，这里i和j是一起的
            if( target >0 && nums[i] + nums[j] > target) break
            // if( nums[j] == nums[j-1]) continue
            if(j > i + 1 && nums[j] === nums[j - 1]) continue;

            let left = j+1
            let right = n-1

            while(left < right){
                let sum = nums[i] + nums[j] + nums[left] + nums[right]
                if(sum > target){
                    right--
                }
                if(sum < target){
                    left++
                }

                if( sum == target){
                    arr.push( [ nums[i], nums[j], nums[left], nums[right] ] )

                    while( left < right && nums[left] == nums[left+1] ){
                        left++
                    }

                    while( left <right && nums[right] == nums[right-1] ){
                        right--
                    }

                    left++
                    right--
                }
            }

        }

    }

    return arr

};
```



### 总结

- `i=0,j=length-1`一般都是使用while循环`while( i <= j )`
- `i=0,j=0`一般配合for循环`let j = 0   for(ley i = 0;...)`



## 栈和队列

### 有效括号

[20. 有效的括号 - 力扣（LeetCode）](https://leetcode.cn/problems/valid-parentheses/)

```js
var isValid = function(s) {
    let a = s.split('')
    // 这个可以不加，加上的话有性能优化
    if(a.length % 2 == 1) return false
    let arr = []
    for(let i = 0;i<s.length;i++){
        switch(s[i]){
            case '(':arr.push(')');break;
            case '[':arr.push(']');break;
            case '{':arr.push('}');break;
            default :
                if(s[i] != arr.pop() ) return false
                break;
        }
    }

    
    return !arr.length
};
```



### 十进制转二进制

```js
function foo(num){
    // 实现的上述的new
    const stack = new ArrayStack()
    let str = ''

    while(num > 0){
        stack.push(num % 2)
        num = Math.floor(num/2)
    }
    
    while(!stack.isEmpty()){
        str += stack.pop()
    }

    return str
}
console.log(foo(35));
```





### 删除字符串中的所有相邻重复项

[1047. 删除字符串中的所有相邻重复项 - 力扣（LeetCode）](https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/)

```js
var removeDuplicates = function(s) {
    let arr = []
    for(const value of s){
        let a = arr.pop()

        if( value != a ){
            arr.push(a)
            arr.push(value)
        }
    }

    return arr.join('')
};
```



### 逆波兰表达式求值

[150. 逆波兰表达式求值 - 力扣（LeetCode）](https://leetcode.cn/problems/evaluate-reverse-polish-notation/)

```js
var evalRPN = function (tokens) {
    const stack = [];
    for (const token of tokens) {
        if (isNaN(token) { // 非数字
            const n2 = stack.pop(); // 出栈两个数字
            const n1 = stack.pop();
            switch (token) { // 判断运算符类型，算出新数入栈
                case "+":
                    stack.push(n1 + n2);
                    break;
                case "-":
                    stack.push(n1 - n2);
                    break;
                case "*":
                    stack.push(n1 * n2);
                    break;
                case "/":
                    // parseInt是只保留整数部分,不能使用Math.floor，因为负数时会出错
                    stack.push(parseInt(n1 / n2));
                    break;
            }
        } else { // 数字
            stack.push(Number(token));
        }
    }
    return stack[0]; // 因没有遇到运算符而待在栈中的结果
};
```



### 滑动窗口最大值

[239. 滑动窗口最大值 - 力扣（LeetCode）](https://leetcode.cn/problems/sliding-window-maximum/)

涉及到堆的知识

### 前 K 个高频元素

[347. 前 K 个高频元素 - 力扣（LeetCode）](https://leetcode.cn/problems/top-k-frequent-elements/)

涉及到堆的知识



## 二叉树

### 遍历

[144. 二叉树的前序遍历 - 力扣（LeetCode）](https://leetcode.cn/problems/binary-tree-preorder-traversal/)

```js
var preorderTraversal = function(root) {
    let arr = []
    nodeMap(root)
    function nodeMap(node){
        if(node){
            arr.push(node.val)
            nodeMap(node.left)
            nodeMap(node.right)
        }
    }
    return arr
};
```



[94. 二叉树的中序遍历 - 力扣（LeetCode）](https://leetcode.cn/problems/binary-tree-inorder-traversal/)

```js
var postorderTraversal = function(root) {
    let arr = []
    nodeMap(root)
    function nodeMap(node){
        if(node){
            nodeMap(node.left)
            arr.push(node.val)
            nodeMap(node.right)
        }
    }
    return arr
};
```



[145. 二叉树的后序遍历 - 力扣（LeetCode）](https://leetcode.cn/problems/binary-tree-postorder-traversal/)

```js
var postorderTraversal = function(root) {
    let arr = []
    nodeMap(root)
    function nodeMap(node){
        if(node){
            nodeMap(node.left)
            nodeMap(node.right)
            arr.push(node.val)
        }
    }
    return arr
};
```



### 层序遍历

[102. 二叉树的层序遍历 - 力扣（LeetCode）](https://leetcode.cn/problems/binary-tree-level-order-traversal/)

```js
var levelOrder = function(root) {
    if(!root) return []
    //二叉树的层序遍历
    let res = [], queue = [root];
    while(queue.length !== 0) {
        // 记录当前层级节点数
        let length = queue.length;
        //存放每一层的节点
        let curLevel = [];
        for(let i = 0;i < length; i++) {
            let node = queue.shift();
            curLevel.push(node.val);
            // 存放当前层下一层的节点
            node.left && queue.push(node.left);
            node.right && queue.push(node.right);
        }
        //把每一层的结果放到结果数组
        res.push(curLevel);
    }
    return res;
};
```



### 反转二叉树

[226. 翻转二叉树 - 力扣（LeetCode）](https://leetcode.cn/problems/invert-binary-tree/)

**先序遍历的方式来反转二叉树**

```js
var invertTree = function(root) {
    if(!root) return null

    let rightNode = root.right
    root.right = invertTree(root.left);
    root.left = invertTree(rightNode);

    return root
};
```



**后序遍历的方式来反转二叉树**

```js
var invertTree = function(root) {
    if(!root) return null

    invertTree(root.left);
    invertTree(root.right);
    [root.left, root.right] = [root.right, root.left]

    return root
};
```



### 对称二叉树

[101. 对称二叉树 - 力扣（LeetCode）](https://leetcode.cn/problems/symmetric-tree/)

#### 使用递归后续遍历

在对左右进行遍历的时候，我们需要知道什么时候返回true，什么时候返回false

- 返回false的情况
  - 左空右不空
  - 左不空右空
  - 左不空右不空值不等
- 返回true的情况
  - 左右为空
- 继续递归的情况
  - 左不空右不空值相等

```js
var isSymmetric = function(root) {
    if(!root) return true
    
    function foo(left, right){
        if(left==null && right != null){
            return false
        }else if(left!=null && right == null){
            return false
        }else if(left == null && right == null){
            return true
        }else if(left != null && right != null && left.val != right.val){
            // left != null && right != null && 是可以省略的，来到这两个一定不是空了，写了方便理解
            return false
        }

        let a = foo(left.left, right.right)
        let b = foo(left.right, right.left)

        return a&&b
    }

    return foo(root.left, root.right)
};
```

```js
// 简单优化
var isSymmetric = function(root) {
    if(!root) return true
    
    function foo(left, right){
        if (left === null && right === null) return true;
        if (left === null || right === null) return false;

        if (left.val !== right.val) {
            return false
        } else {
            return foo(left.left, right.right) && foo(left.right, right.left)
        }
    }

    return foo(root.left, root.right)
};
```





#### 队列实现迭代判断是否为对称二叉树

```js
var isSymmetric = function(root) {
  if(!root) return true;
  let queue = [];
  queue.push(root.left);
  queue.push(root.right);
  while(queue.length) {
      let leftNode = queue.shift();    //左节点
      let rightNode = queue.shift();   //右节点
      if(leftNode === null && rightNode === null) {
          continue;
      }
      if(leftNode === null || rightNode === null || leftNode.val !== rightNode.val) {
          return false;
      }
      queue.push(leftNode.left);     //左节点左孩子入队
      queue.push(rightNode.right);   //右节点右孩子入队
      queue.push(leftNode.right);    //左节点右孩子入队
      queue.push(rightNode.left);    //右节点左孩子入队
  }
  
  return true;
};
```

用栈的思路与队一样，展示取数据的位置不一样



### 二叉树的最大深度

[104. 二叉树的最大深度 - 力扣（LeetCode）](https://leetcode.cn/problems/maximum-depth-of-binary-tree/)

我们先区分什么是高度，什么是深度（高度深度为1还是0仅仅是一个规则，不用太纠结） 

#### 层序遍历后返回长度

这个思路比较好想到，但是效率不高

```js
var maxDepth = function(root) {
    // 层续遍历
    if(!root) return 0

    let arr1 = []
    let arr2 = [root]

    while(arr2.length){
        let arr3 = []
        let n = arr2.length
        for(let i = 0;i<n;i++){
            let x = arr2.shift()
            arr3.push(x)
            x.left && arr2.push(x.left)
            x.right && arr2.push(x.right)
        }
        arr1.push(arr3)
    }

    return arr1.length
};
```



#### 后序遍历的思路

**求深度一般是前序遍历，求高度是后续遍历**

那为什么这题是用后续遍历呢？核心是：**根节点的深度就是二叉树的深度**

```js
var maxDepth = function(root) {
    if(!root) return 0

    // 后序遍历：左右中
    let left = maxDepth(root.left)
    let right = maxDepth(root.right)
    let num = Math.max(left, right) + 1
    return num

};
```



### 二叉树的最小深度

[111. 二叉树的最小深度 - 力扣（LeetCode）](https://leetcode.cn/problems/minimum-depth-of-binary-tree/)

这题我们要注意，题目给我们的描述是   **最小深度是从根节点到最近叶子节点的最短路径上的节点数量**

我们的思路还是和求最大深度一样，我们求根节点的最小高度，就定义根节点的最小深度

```js
var minDepth = function(root) {
    if(!root) return 0

    let left = minDepth(root.left)
    let right = minDepth(root.right)

    // 这里我们不能直接去min，我们要去除根节点左右子树可能为空的情况

    if(root.left == null && root.right != null){
        return right+1
    }

    if(root.left != null && root.right == null){
        return left+1
    }

    let num = Math.min(left, right) + 1
    return num
};
```



### 完全二叉树的节点个数

[222. 完全二叉树的节点个数 - 力扣（LeetCode）](https://leetcode.cn/problems/count-complete-tree-nodes/)

如果这是一个普通的二叉树，我们可以通过前中后或层序遍历去求解（层序遍历使用一维数组的方式）

既然题目强调了是完全二叉树，我们可以通过完全二叉书的特性去解题

设深度为n，满二叉树的计算节点：2^n^-1

```js
// 终止条件我们有两个，节点为空和节点为满二叉树

var countNodes = function(root) {
    // 节点为空
    if(!root) return 0

    //满二叉树的终止条件
    let leftSize = 0
    let rightSize = 0

    let left = root.left
    let right = root.right

    while(left){
        left = left.left
        leftSize++
    }
    while(right){
        right = right.right
        rightSize++
    }
	//2 ** n-1
    if(leftSize == rightSize) return 2 ** (leftSize+1) - 1

    // 纪录左右节点数的数量:左右中
    let leftNum = countNodes(root.left)
    let rightNum = countNodes(root.right)

    let result = leftNum + rightNum + 1
    return result

};
```



### 平衡二叉树

[110. 平衡二叉树 - 力扣（LeetCode）](https://leetcode.cn/problems/balanced-binary-tree/)

**递归法**

```js
var isBalanced = function(root) {
    
    function deep(node){
        if(!node) return 0
        
        // let left = deep(node.left)
        // if(left === -1) return -1
        // let right = deep(node.right)
        // if(right === -1) return -1
        
        let left = deep(node.left)
        let right = deep(node.right)
        if(right === -1 || left === -1) return -1

        return Math.abs(left - right) > 1 ? -1 : Math.max(left, right) + 1
    }

    return deep(root) !== -1
};
```





### 总结

[代码随想录：二叉树总结](https://www.programmercarl.com/二叉树总结篇.html#阶段总结)

- 求深度一般是前序遍历
  - 统计往下的，1 2 3 4
- 求高度是后续遍历
  - 层层向上，（从上往下是4 3 2 1）

- 在二叉树中，我们要遍历的话一定要确定我们使用的是哪种遍历方式：前中后序

  - 前序遍历：中左右。中序遍历：左中右。后序遍历：左右中。


  - 一般需要我们收集孩子的信息向上一层返回的时候都会使用后续遍历



## 回溯法

### 理论基础

回溯算法能解决如下问题：

- 组合问题：N个数里面按一定规则找出k个数的集合
- 排列问题：N个数按一定规则全排列，有几种排列方式
- 切割问题：一个字符串按一定规则有几种切割方式
- 子集问题：一个N个数的集合里有多少符合条件的子集
- 棋盘问题：N皇后，解数独等等



**回溯和递归是相辅相成**

- 先确定递归函数参数和返回值
- 确定终止条件
- 单层递归的逻辑

```js
// 回溯法的模板框架
function backtracking(参数) {
    if (终止条件) {
        存放结果;
        return;
    }

    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
        处理节点;
        backtracking(路径，选择列表); // 递归
        回溯，撤销处理结果
    }
}
```



### 组合

[77. 组合 - 力扣（LeetCode）](https://leetcode.cn/problems/combinations/)

```js
var combine = function(n, k) {
   let arr = []
   let arr1 = []
	// startIndex：控制当前递归层下一步从哪开始递归
    function foo(n, k, startIndex){
        // 终止条件
        if(arr1.length === k){
            // 进行一层浅拷贝，否则在下面pop的时候会影响这里
            arr.push([...arr1])
            return
        }

        for(let i = startIndex; i <= n;i++){
            arr1.push(i)
            // 递归下一个
            foo(n, k, i + 1)
            // 回溯
            arr1.pop()
        }
    }

    foo(n, k, 1)

    return arr
};
```



**优化：剪枝操作**

减的就是节点的子孩子，我们要对for循环里面的语句进行操作，来确保定个数不足的时候，后面的操作我们就直接减去了

- arr1中存放这我们已经选取了元素，那么我们还剩 `k - arr1.length` 个元素需要选取进入到这个arr1中
- 那么我们选取的位置最大的位置就是 `n - ( k - arr1.length ) + 1`。为什么要+1，因为那个位置是可以取到的。
- 在这个最大位置之前的index我们都还可以取，在这个之后，个数已经无法满足了

就是我们的for循环没有必要循环到 n ，循环到`n - ( k - arr1.length ) + 1`，即可，在这个之后的数据一定是不满足的

```js
var combine = function(n, k) {
   let arr = []
   let arr1 = []

    function foo(n, k, startIndex){
        // 终止条件
        if(arr1.length === k){
            // 进行一层浅拷贝，否则在下面pop的时候会影响这里
            arr.push([...arr1])
            return
        }

        for(let i = startIndex; i <= n - ( k - arr1.length ) + 1;i++){
            arr1.push(i)
            // 递归下一个
            foo(n, k, i + 1)
            // 回溯
            arr1.pop()
        }
    }

    foo(n, k, 1)

    return arr
};
```



### 组合总和 III

[216. 组合总和 III - 力扣（LeetCode）](https://leetcode.cn/problems/combination-sum-iii/)

```js
var combinationSum3 = function(k, n) {
    let arr = []
    let arr1 = []

    function foo(k ,n, sum, startIndex){
        if(arr1.length === k && sum === n){
            arr.push([...arr1])
            return
        }

        for(let i = startIndex; i <= 9;i++){
            arr1.push(i)
            sum += i
            foo(k, n, sum, i+1)
            sum -= i
            arr1.pop()
        }
    }

    foo(k, n, 0, 1)

    return arr
};
```

**剪枝操作**

```js
var combinationSum3 = function(k, n) {
    let arr = []
    let arr1 = []

    function foo(k ,n, sum, startIndex){
        // 剪枝操作
        if(sum > n) return
        
        if(arr1.length === k && sum === n){
            arr.push([...arr1])
            return
        }
		// 剪枝操作，与上述组合问题的原理相同
        for(let i = startIndex; i <= 9 - ( k - arr1.length ) + 1;i++){
            arr1.push(i)
            sum += i
            foo(k, n, sum, i+1)
            sum -= i
            arr1.pop()
        }
    }

    foo(k, n, 0, 1)

    return arr
};
```



### 电话号码的字母组合

[17. 电话号码的字母组合 - 力扣（LeetCode）](https://leetcode.cn/problems/letter-combinations-of-a-phone-number/)

```js
var letterCombinations = function(digits) {

    let list = [
        [],
        [],
        ['a', 'b', 'c'],
        ['d', 'e', 'f'],
        ['g', 'h', 'i'],
        ['j', 'k', 'l'],
        ['m', 'n', 'o'],
        ['p', 'q', 'r', 's'],
        ['t', 'u', 'v'],
        ['w', 'x', 'y', 'z'],
    ]

    if(!digits.length) return []

    let arr = []
    let str = ''

    function foo(digits, index){

        if(str.length === digits.length){
            arr.push(str)
            return
        }

        // 取到我们的那个数组
        let map = list[digits[index]]
        for(let i = 0;i<map.length;i++){
            str += map[i]
            foo(digits, index+1)
            str = str.slice(0, str.length - 1)
        }

    }

    foo(digits, 0)

    return arr
};
```





### 组合总和

[39. 组合总和 - 力扣（LeetCode）](https://leetcode.cn/problems/combination-sum/)

```js
var combinationSum = function(candidates, target) {
    let arr = []
    let arr1 = []

    function foo(candidates, target, sum, startIndex){

        if(sum > target) return

        if(sum === target){
            arr.push([...arr1])
            return
        }

        for(let i = startIndex;i< candidates.length; i++){
            arr1.push(candidates[i])
            sum += candidates[i]
            // 与上述不同的是，我们这里从 i 开始，因为可以取重复的元素
            foo(candidates, target, sum, i)
            sum -= candidates[i]
            arr1.pop()
        }

    }

    foo(candidates, target, 0, 0)

    return arr
};
```



### 组合总和 II

[40. 组合总和 II - 力扣（LeetCode）](https://leetcode.cn/problems/combination-sum-ii/)

这道题不同的就是，给我们的数组中可能**存在重复元素**

所有我们就要进行一个去重的操作。但是我们选择得到结果后去重还是在组合的时候就去重，这是关键点

```js
var combinationSum2 = function(candidates, target) {
    let arr = []
    let arr1 = []
    candidates.sort((a,b)=>a-b)
    function foo(candidates, target, sum, startIndex){
        if( sum > target ) return
        if( sum === target ){
            arr.push([...arr1])
            return
        }
		
        // 这里为什么做不了剪枝操作：因为我们不确定我们数组的个数
        for(let i = startIndex; i < candidates.length;i++){
            // 树层去重的操作 前一个去当前相等的时候continue，核心要理解这个  i > startIndex
            if( i > startIndex && candidates[i] === candidates[i-1] ){
                continue
            }
            sum += candidates[i]
            arr1.push(candidates[i])
            foo(candidates, target, sum, i+1)
            sum -= candidates[i]
            arr1.pop()
        }

    }

    foo(candidates, target, 0, 0)

    return arr
};
```

理解：`if( i > startIndex && candidates[i] === candidates[i-1] )`

- 当 `i` 等于 `startIndex` 时，说明我们是在当前层级的起始位置，此时我们可以自由选择当前元素作为组合的一部分，而不会重复
- 但是，如果 `i` 大于 `startIndex`，说明我们已经选择过一个元素并进入了下一个位置，如果后续的元素与前一个元素相同，则会导致生成的组合重复。



### 分割回文数

[131. 分割回文串 - 力扣（LeetCode）](https://leetcode.cn/problems/palindrome-partitioning/)

```js
/**
 * @param {string} s
 * @return {string[][]}
 */
var partition = function(s) {
    if(s.length === 1) return [[s]]

    let arr = []
    let arr1 = []
	
    // 判断是否为回文串
    function isFoo(str){
        let i = 0
        let j = str.length - 1

        while(i <=j){
            if( str[i] === str[j] ){
                i++
                j--
            }else{
                return false
            }
        }

        return true
    }

    function foo(s, startIndex){
        // 已经切割到末尾了，终止
        if( startIndex >= s.length ){
            arr.push([...arr1])
            return
        }

        for(let i = startIndex;i<s.length;i++){
            // 切割的子串：[startIndex, i]
            let str = s.slice(startIndex, i+1)
            // 判断回文数
            if(!isFoo(str)) continue
            
            arr1.push(str)
            foo(s, i+1)
            // 回溯操作
            arr1.pop()
        }

    }

    foo(s, 0)
    return arr
};
```



### 复原IP地址

[93. 复原 IP 地址 - 力扣（LeetCode）](https://leetcode.cn/problems/restore-ip-addresses/)

我们的思路是和上题分割回文数的思路相同的，我们将判断回文数是否合法放在了循环里

```js
var restoreIpAddresses = function(s) {
    const n = s.length
    if(n < 4 || Number.isNaN(s) ) return []

    let arr = []
    let arr1 = []

    // 判断每一个字符串是否合法, 
    function isFoo(x){
        if( x == '0') return true
        if( Number(x) >= 0 && Number(x) <= 255 && x[0] != 0 ){
            return true
        }else{
            return false
        }
    }

    function foo(s, startIndex ){
        // 3个点
        if( arr1.length === 4 ){
            let a = arr1.join('.')
            if( a.length - 3 === s.length ){
                arr.push(a)
            }
            return
        }

        for(let i = startIndex;i<n;i++){

            let x = s.substring(startIndex, i +1)
            if( !isFoo(x) ) continue
            arr1.push(x)
            foo(s, i+1)
            // 回溯
            arr1.pop()

        }

    }

    foo(s, 0)
    return arr
};
```



### 子集

[78. 子集 - 力扣（LeetCode）](https://leetcode.cn/problems/subsets/)

```js
var subsets = function(nums) {
    const n = nums.length
    let arr = []
    let arr1 = []
    function foo(nums, startIndex){
        // 每一次进入递归我们的需要收集结果
        arr.push([...arr1])
        // 终止条件:到达底部节点
        if(startIndex >= n) return

        for(let i = startIndex ;i < n ;i++){
            arr1.push(nums[i])
            foo(nums, i+1)
            arr1.pop()
        }
    }

    foo(nums, 0)
    return arr
};
```



### 子集 II

[90. 子集 II - 力扣（LeetCode）](https://leetcode.cn/problems/subsets-ii/)

与上一题不用的是，数组中可能存在重复的元素

去重的思路和组合总和II的思路一样

```js
var subsetsWithDup = function(nums) {
    const n = nums.length
    nums.sort((a,b)=>a-b)
    let arr = []
    let arr1 = []

    function foo(nums, startIndex){
        arr.push([...arr1])
        if( startIndex >= n ) return

        for(let i = startIndex;i<n;i++){
            if( i > startIndex && nums[i-1] === nums[i] ) continue
            arr1.push(nums[i])
            foo(nums, i+1)
            arr1.pop()
        }

    }

    foo(nums, 0)

    return arr
};
```



### 递增子序列

[491. 递增子序列 - 力扣（LeetCode）](https://leetcode.cn/problems/non-decreasing-subsequences/)

这题我们不仅涉及到选择的问题，还是涉及到了去重，最重要的是我们不能对数组进行排序

```js
var findSubsequences = function(nums) {
    const n = nums.length

    let arr = []
    let arr1 = []

    function foo(nums, startIndex){
        // 多了一个条件 
        if(arr1.length >=2 ) arr.push([...arr1])
        // if(startIndex >= n) return

        // 我们之前去重是通过排序进行，比较前后是否相等
        // 这里我们不能排序，我们使用set
        let list = new Set()
        for(let i = startIndex; i< n;i++){
            let a = nums[i]
            
            //加入的时候要进行一个选择
            // 去重 + 前一个比后一个小
            if( (arr1.length && a < arr1[arr1.length - 1]) || list.has(a) ) continue
            list.add(a)
            arr1.push(a)
            foo(nums, i+1)
            arr1.pop()
        }
    }

    foo(nums, 0)

    return arr
};
```



### 全排列

[46. 全排列 - 力扣（LeetCode）](https://leetcode.cn/problems/permutations/)

```js
var permute = function(nums) {
    const n = nums.length
    let arr = []
    let arr1 = []
	
    //这里我们使用了一个used数组，来纪录我们当前选择了什么，之后在这一层就不能选了
    function foo(nums, used){
        if( arr1.length === n ){
            arr.push([...arr1])
            return
        }

        for(let i = 0;i<n;i++){
            if(used[i]) continue
            arr1.push(nums[i])
            used[i] = true
            foo(nums, used)
            arr1.pop()
            used[i] = false
        }
    }

    foo(nums, [])
    
    return arr
};
```



### 全排列 II

[47. 全排列 II - 力扣（LeetCode）](https://leetcode.cn/problems/permutations-ii/)

去重操作

```js
var permuteUnique = function(nums) {
    const n = nums.length
    let arr = []
    let arr1 = []
	nums.sort((a, b)=> a-b)
    function foo(nums, used){
        if( arr1.length === n ){
            arr.push([...arr1])
            return
        }

        for(let i = 0;i<n;i++){
            if(used[i]) continue
            //去重：如何知道我们是树层去重呢 ： !used[i - 1]，当前一个是false的时候，我们才是树层
            if( i > 0 && nums[i] === nums[i - 1] && !used[i - 1] ) continue
            arr1.push(nums[i])
            used[i] = true
            foo(nums, used)
            arr1.pop()
            used[i] = false
        }
    }

    foo(nums, [])
    
    return arr
};
```



### 总结

- 像第一二题，我们使用的是startIndex， 是这样因为我们在一个集合里，为了避免重复，我们需要控制循环的位置。第三题使用index，在多个集合中，不需要控制循环位置，我们想要知道我们当前循环到哪个位置上了
- 区分排列和组合的区别
  - 排列[1, 2]和[2, 1]相同。组合不同
  - 排列我们一般使用startIndex来纪录选择的位置，因为选择位置之前的不能被选了
  - 组合我们一般用一个数组used来表示当前哪个被选中了


- 什么时候用startIndex，什么时候用index
  - 在循环树层的时候，选择了这个树层，就不能再次选择了避免重复
- 递归调用是i还是i+1
  - 使用i的情况，表示在树枝中我们可以取到与树层相同的数（如题组合总和）
  - 当树枝取不到树层的数据的时候，就使用i+1
- 终止条件的情况
  - 数组组合的我们一般都是判断是否满足题目要求，如数组和、数组长度等等
  - 类似于切割回文数这样的题，需要将整个字符切割完才行，就是`startIndex >= s.length`
  - 没有条件约束我们可以直接push，如子集I和II
- 当我们需要去数组进行排序，然后对得出的结果进行去重的时候，一般的去重条件`i > startIndex && arr[i] === arr[i-1]`





## 动态规划

### 理论基础

- 动态规划的核心思想是将问题划分为若干个子问题，并在计算子问题的基础上,，逐步构建出原问题的解
- 具体地说，动态规划通常涉及以下四个步骤:
  - 步骤一：定义状态。
    - 将原问题划分为若千个子问题，定义状态表示子问题的解，通常使用一个数组或者矩阵来表示。
  - 步骤二：确定状态转移方程。
    - 在计算子问题的基础上，逐步构建出原问题的解。
    - 这个过程通常使用“状态转移方程”来描述，表示从一个状态转移到另一个状态时的转移规则。
  - 步骤三：初始化状态。
  - 步骤四：计算原问题的解(最终答案)。
    - 通过计算状态之间的转移，最终计算出原问题的解。√通常使用递归或者迭代(循环)的方式计算。

- 代码随想录动规五部曲
  - 确定dp数组（dp table）以及下标的含义
  - 确定递推公式
  - dp数组如何初始化
  - 确定遍历顺序
  - 举例推导dp数组



### 斐波拉契数列

[509. 斐波那契数 - 力扣（LeetCode）](https://leetcode.cn/problems/fibonacci-number/)

这是一道和入门的动态规划类的题目，当然他也有很多其他的解法

**递归**

```js
var fib = function(n) {
    if(n == 0 || n== 1) return n
    return fib(n-1) + fib(n-2)
};
```

**动态规划**

```js
var fib = function(n) {
    let arr = [0, 1]
    for(let i = 2;i<=n;i++){
        arr[i] = arr[i-1] + arr[i-2]
    }
    return arr[n]
};
```

```js
// 状态压缩：我们发现，我们获取现在的值只依赖与上一个值和上上个值，对于其他的值没有必要去纪录占用空间
var fib = function(n) {
    if( n <= 1) return n
    pre = 0
    cur = 1
    for(let i = 2;i<=n;i++){
        const value = pre + cur
        pre = cur
        cur = value
    }
    return cur
};
```



### 爬楼梯

[70. 爬楼梯 - 力扣（LeetCode）](https://leetcode.cn/problems/climbing-stairs/description/)

与斐波拉契数列的思想是一样的，只是初始化值不一样

```js
var climbStairs = function(n) {
    if(n <= 1) return 1
    let pre = 1
    let cur = 1

    for(let i = 2;i<=n;i++){
        const value = pre + cur
        pre = cur
        cur =value
    }

    return cur
}; 
```



### 使用最小花费爬楼梯

[746. 使用最小花费爬楼梯 - 力扣（LeetCode）](https://leetcode.cn/problems/min-cost-climbing-stairs/)

- 确定dp数组以及下标的含义：i表示我们在哪个楼梯上，dp[i]表示当前楼梯的最小花费
- 确定递推公式
  - i-1的位置跳一步到i，或者i-2的位置跳两步到i
  - `dp[i] = Math.min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2])`
- dp数组如何初始化：`dp[0] = 0, dp[1] = 0`
- 确定遍历顺序：顺序
- 举例推导dp数组

```js
var minCostClimbingStairs = function(cost) {
    let dp = [0, 0]

    for(let i = 2;i<=cost.length;i++){
        dp[i] = Math.min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2])
    }

    return dp[cost.length]
};
```

```js
// 状态压缩
var minCostClimbingStairs = function(cost) {
    let pre = 0
    let cur = 0

    for(let i = 2;i<=cost.length;i++){
        const value = Math.min(cur + cost[i - 1], pre + cost[i - 2])
        pre = cur
        cur = value
    }

    return cur
};
```



### 不同路径

[62. 不同路径 - 力扣（LeetCode）](https://leetcode.cn/problems/unique-paths/)

- 确定dp数组以及下标的含义：dp[i] [j]表示到达(i, j)的位置所经历的所有可能路径数，(i,j)表示位置
- 确定递推公式：`dp[m][n] = dp[m-1][n] + dp[m][n-1]`
- dp数组初始化：`dp[0][0] = 0;dp[0][j] = 1;dp[i][0] = 1`
- 确定遍历顺序

```js
var uniquePaths = function(m, n) {
    let dp = new Array(m).fill(1).map(() => new Array(n).fill(1))
    for(let i = 1;i<m;i++){
        for(let j = 1;j<n;j++){
            dp[i][j] = dp[i-1][j] + dp[i][j-1]
        }
    }

    return dp[m-1][n-1]
};
```



### 不同路径 II

[63. 不同路径 II - 力扣（LeetCode）](https://leetcode.cn/problems/unique-paths-ii/)

- 确定dp数组以及下标的含义：dp[i] [j]表示到达(i, j)的位置所经历的所有可能路径数，(i,j)表示位置
- 确定递推公式：`dp[m][n] = dp[m-1][n] + dp[m][n-1]`（有前提条件了，因为可能有障碍）
- dp数组初始化：`dp[0][0] = 0;dp[0][j] = 1;dp[i][0] = 1`（同样也是的，在遇到第一个障碍之后，后面的都走不了了）
- 确定遍历顺序

```js
var uniquePathsWithObstacles = function(obstacleGrid) {
    let m = obstacleGrid.length
    let n = obstacleGrid[0].length
    let dp = new Array(m).fill(0).map(()=> new Array(n).fill(0))
    for(let i = 0;i<m && obstacleGrid[i][0] == 0 ;i++){
        dp[i][0] = 1
    }

    for(let j = 0;j<n && obstacleGrid[0][j] == 0 ;j++){
        dp[0][j] = 1
    }

    for(let i = 1;i<m;i++){
        for(let j = 1;j<n;j++){
            if(obstacleGrid[i][j] == 1){
                dp[i][j] = 0
            }else{
                dp[i][j] = dp[i-1][j] + dp[i][j-1]
            }
        }
    }

    return dp[m-1][n-1]
};
```

```js
// 内存优化
var uniquePathsWithObstacles = function(obstacleGrid) {
    const m = obstacleGrid.length;
    const n = obstacleGrid[0].length;
    for (let i = 0; i < m; i++) {
        for (let j = 0; j < n; j++) {
            if (obstacleGrid[i][j] === 0) {
                // 不是障碍物
                if (i === 0) {
                    // 取左边的值
                    obstacleGrid[i][j] = obstacleGrid[i][j - 1] ?? 1;
                } else if (j === 0) {
                    // 取上边的值
                    obstacleGrid[i][j] = obstacleGrid[i - 1]?.[j] ?? 1;
                } else {
                    // 取左边和上边的和
                    obstacleGrid[i][j] = obstacleGrid[i - 1][j] + obstacleGrid[i][j - 1];
                }
            } else {
                // 如果是障碍物，则路径为0
                obstacleGrid[i][j] = 0;
            }
        }
    }
    return obstacleGrid[m - 1][n - 1];
};
```



### 买卖股票

[121. 买卖股票的最佳时机 - 力扣（LeetCode）](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/)

```js
// 遍历最后数组找到最大值
function foo(prices){
    const n = prices.length
    if(prices <= 1) return 0
    // 定义状态
    let dp = []

    // 设置初始化值
    dp[0] = 0

    // 状态转移方程，求do[i]
    let minPrice = prices[0]
    for (let i = 1; i < n; i++) {
        // 当前i位置 减去 前一个最小值
        dp[i] = prices[i] - minPrice
        // 获取当前最小值
        minPrice = Math.min( prices[i], minPrice )
    }

    return Math.max(...dp)
}
```



### 最大子数组和

[53. 最大子数组和 - 力扣（LeetCode）](https://leetcode.cn/problems/maximum-subarray/)

```js
function foo(nums){
    const n = nums.length
    // 定义状态：dp[i]：以i结尾的连续子数组的最大和
    let dp = []

    // 初始化值
    dp[0] = nums[0]

    // 转移方程
    for (let i = 1; i < n; i++) {
        dp[i] = Math.max(nums[i], nums[i] + dp[i-1])
    }

    return Math.max(...dp)
}
```

```js
// 状态压缩
function foo(nums){
    const n = nums.length

    // 初始化值：这种设计到之和前一个有关的数据，用一个变量定义，更新这个变量即可
    let preValues = nums[0]

    let max = preValues
    // 转移方程
    for (let i = 1; i < n; i++) {
        preValues= Math.max(nums[i], nums[i] + preValues)
        max = Math.max( preValues, max )
    }

    return max
}
```



### 整数拆分

[343. 整数拆分 - 力扣（LeetCode）](https://leetcode.cn/problems/integer-break/)

- 确定dp数组及其下标值含义：拆解i的乘积dp[i]
- 递推公式：`拆成两个：j * (i - j);拆成三个及以上：j * dp[i - j]`
- 初始化值：`dp[0]=0;dp[1]=0;dp[2]=1`
- 确定遍历顺序

```js
var integerBreak = function(n) {
    if( n <=1 ) return 0
    let dp = new Array(n+1).fill(0)
    
    dp[2] = 1

    for(let i = 3;i<=n;i++){
        // 拆分i
        for(let j = 1;j <= i/2;j++){
            dp[i] = Math.max( j * (i-j), j * dp[i-j], dp[i] )
        }
    }

    return dp[n]
};
```

### 01背包问题

#### 分割等和子集

[416. 分割等和子集 - 力扣（LeetCode）](https://leetcode.cn/problems/partition-equal-subset-sum/)

这是一个01背包问题

- 确定dp数组及其下标值的含义
  - `dp[j]：容量`为j的背包所背的最大价值
- 确定递推公式
  - `dp[j] = Math.max( dp[j], dp[ j- weight[j] ] + value[j] )`
- 确定初始化值
- 遍历顺序

```js
var canPartition = function(nums) {
    const sum = nums.reduce((p,v) => p + v)
    if (sum % 2 == 1) return false;

    let target = sum/2;

    let dp = new Array( target + 1 ).fill(0);
	
    // 先物品，后价值
    for(let i = 0;i< nums.length ;i++){
        for(let j = target; j >= nums[i];j--){
            dp[j] = Math.max( dp[j], dp[j - nums[i]] + nums[i] )
        }
    }

    return dp[target] === target
};
```



#### 最后一块石头的重量 II

[1049. 最后一块石头的重量 II - 力扣（LeetCode）](https://leetcode.cn/problems/last-stone-weight-ii/)

- 明确dp及其下标值的含义
  - dp[j]的最大重量
- 递推公式
  - `dp[j] = Math.max( dp[j], dp[ j- weight[j] ] + value[j] )`
- 初始化值
- 遍历顺序 

```js
var lastStoneWeightII = function(stones) {

    const num = stones.reduce((a,b) => a+b)
    const target = Math.floor(num/2)

    let dp = new Array(target + 1).fill(0)

    for(let i = 0;i < stones.length;i++){

        for(let j = target; j >= stones[i];j--){
            dp[j] = Math.max( dp[j], dp[j - stones[i]] + stones[i] )
        }

    }

    // 应该是：( num - dp[target] ) - dp[target]
    return num - dp[target] - dp[target]

};
```



#### 目标和

[494. 目标和 - 力扣（LeetCode）](https://leetcode.cn/problems/target-sum/)

- 明确dp及其下标值的含义
  - dp[j]的最多组成次数
- 递推公式
  - `dp[j] = dp[j] + do[j - nums[i]] `
- 初始化值
  - dp[0]为1
- 遍历顺序 

```js
var findTargetSumWays = function(nums, target) {
    const sum = nums.reduce((a,b)=>a+b)
    if(Math.abs(target) > sum) return 0;
    if( (target + sum)%2 === 1 ) return 0
    const midNum = (target + sum)/2
    
    let dp = new Array(midNum+1).fill(0)
    dp[0] = 1
    
    for(let i = 0;i<nums.length;i++){
        for(let j = midNum; j >= nums[i];j--){
            dp[j] = dp[j] + dp[j - nums[i]]
        }
    }

    return dp[midNum]

};
```



### 完全背包问题

#### 零钱兑换 II

[518. 零钱兑换 II - 力扣（LeetCode）](https://leetcode.cn/problems/coin-change-ii/)

- dp数组含义：装满容量为j的背包需要多少  dp[j]
- 递归公式：`dp[j] = dp[j] + dp[j-coins[i]]`
- 初始化值：dp[0] = 1

```js
var change = function(amount, coins) {

    const n = coins.length
    let dp = new Array(amount+1).fill(0)
    dp[0] = 1
    for(let i = 0;i<n;i++){
        for(let j = coins[i]; j <= amount; j++){
            dp[j] = dp[j] + dp[ j - coins[i] ]
        }
    }

    return dp[amount]

};
```



#### 组合总数 IV

[377. 组合总和 Ⅳ - 力扣（LeetCode）](https://leetcode.cn/problems/combination-sum-iv/)

```js
var combinationSum4 = function(nums, target) {

    const n = nums.length

    let dp = new Array(target+1).fill(0)
    
    dp[0] = 1

    // for(let i = 0;i<n;i++){
    //     for(let j = nums[i];j <= target;j++){
    //         dp[j] = dp[j] + dp[ j - nums[i]]
    //     }
    // }

    for(let j = 0; j<= target;j++){
        for(let i = 0; i < n;i++){
            if(j >= nums[i]){
                 dp[j] = dp[j] + dp[ j - nums[i]]
            }
        }
    }

    return dp[target]
};
```



#### 零钱兑换

[322. 零钱兑换 - 力扣（LeetCode）](https://leetcode.cn/problems/coin-change/)

- dp数组含义
  - dp[j]：组成金额j的最少硬币数
- 递推公式
  - `dp[j] = Math.min(dp[i], dp[j - coins[i]] + 1)`
- 初始化值
  - 最大值

```js
var coinChange = function(coins, amount) {
    const n = coins.length

    let dp = new Array(amount+1).fill(Infinity)
    dp[0] = 0

    for(let i = 0;i<n;i++){
        for(let j = coins[i];j<= amount;j++){
            dp[j] = Math.min(dp[j], dp[j - coins[i]] + 1)
        }
    }

    return dp[amount] === Infinity ? -1 : dp[amount]

};
```



#### 完全平方数

[279. 完全平方数 - 力扣（LeetCode）](https://leetcode.cn/problems/perfect-squares/)

- dp数组含义
  - 和为j的最少子数dp[j]
- 递推公式
  - `dp[j] = dp[j] + dp[j - i * i]`
- 初始化值

```js
var numSquares = function(n) {
    let dp = new Array(n+1).fill(Infinity)
    dp[0] = 0
    // i*i<=n 即可
    for(let i = 1;i*i<=n;i++){
        for(let j = i*i;j<=n;j++){
            dp[j] = Math.min(dp[j], dp[j - i*i] + 1)
        }
    }

    return dp[n]
};
```



### 总结

- 最大值的递推公式：`dp[j] = Math.max( dp[j], dp[ j- weight[j] ] + value[j] )`
- 和的递推公式：`dp[j] = dp[j] + do[j - nums[i]]`
- 最小组合的递推公式：`dp[j] = Math.min(dp[i], dp[j - coins[i]] + 1)`
- 01背包遍历背包j--，完全背包遍历背包j++
- 组合问题先遍历物品在遍历背包，排列问题先遍历背包在遍历物品











